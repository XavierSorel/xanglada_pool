[4mstpncpy[24m(3)                      Library Functions Manual                      [4mstpncpy[24m(3)

[1mNAME[0m
       stpncpy,  strncpy  -  fill a fixed-size buffer with non-null bytes from a string,
       padding with null bytes as needed

[1mLIBRARY[0m
       Standard C library ([4mlibc[24m, [4m-lc[24m)

[1mSYNOPSIS[0m
       [1m#include <string.h>[0m

       [1mchar *strncpy(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                     [1msize_t [4m[22mdsize[24m[1m);[0m
       [1mchar *stpncpy(char [4m[22mdst[24m[1m[restrict .[4m[22mdsize[24m[1m], const char *restrict [4m[22msrc[24m[1m,[0m
                     [1msize_t [4m[22mdsize[24m[1m);[0m

   Feature Test Macro Requirements for glibc (see [1mfeature_test_macros[22m(7)):

       [1mstpncpy[22m():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _GNU_SOURCE

[1mDESCRIPTION[0m
       These functions copy non-null bytes from the string pointed to by  [4msrc[24m  into  the
       array  pointed  to  by [4mdst[24m.  If the source has too few non-null bytes to fill the
       destination, the functions pad the destination with trailing null bytes.  If  the
       destination buffer, limited by its size, isn't large enough to hold the copy, the
       resulting  character  sequence  is truncated.  For the difference between the two
       functions, see RETURN VALUE.

       An implementation of these functions might be:

           char *
           strncpy(char *restrict dst, const char *restrict src, size_t dsize)
           {
               stpncpy(dst, src, dsize);
               return dst;
           }

           char *
           stpncpy(char *restrict dst, const char *restrict src, size_t dsize)
           {
               size_t  dlen;

               dlen = strnlen(src, dsize);
               return memset(mempcpy(dst, src, dlen), 0, dsize - dlen);
           }

[1mRETURN VALUE[0m
       [1mstrncpy[22m()
              returns [4mdst[24m.

       [1mstpncpy[22m()
              returns a pointer to one after the last character in the destination charâ€
              acter sequence.

[1mATTRIBUTES[0m
       For an explanation of the terms used in this section, see [1mattributes[22m(7).
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ [1mInterface                                           [22mâ”‚ [1mAttribute     [22mâ”‚ [1mValue   [22mâ”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚ [1mstpncpy[22m(), [1mstrncpy[22m()                                â”‚ Thread safety â”‚ MT-Safe â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[1mSTANDARDS[0m
       [1mstrncpy[22m()
              C11, POSIX.1-2008.

       [1mstpncpy[22m()
              POSIX.1-2008.

[1mHISTORY[0m
       [1mstrncpy[22m()
              C89, POSIX.1-2001, SVr4, 4.3BSD.

       [1mstpncpy[22m()
              glibc 1.07.  POSIX.1-2008.

[1mCAVEATS[0m
       The name of these functions is confusing.  These functions produce a  null-padded
       character sequence, not a string (see [1mstring_copying[22m(7)).  For example:

           strncpy(buf, "1", 5);       // { '1',   0,   0,   0,   0 }
           strncpy(buf, "1234", 5);    // { '1', '2', '3', '4',   0 }
           strncpy(buf, "12345", 5);   // { '1', '2', '3', '4', '5' }
           strncpy(buf, "123456", 5);  // { '1', '2', '3', '4', '5' }

       It's impossible to distinguish truncation by the result of the call, from a charâ€
       acter  sequence  that  just fits the destination buffer; truncation should be deâ€
       tected by comparing the length of the input string with the size of the  destinaâ€
       tion buffer.

       If  you're going to use this function in chained calls, it would be useful to deâ€
       velop a similar function that accepts a pointer to the end (one  after  the  last
       element) of the destination buffer instead of its size.

[1mEXAMPLES[0m
       #include <err.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>

       int
       main(void)
       {
           char    *p;
           char    buf1[20];
           char    buf2[20];
           size_t  len;

           if (sizeof(buf2) < strlen("Hello world!"))
               errx("strncpy: truncating character sequence");
           strncpy(buf2, "Hello world!", sizeof(buf2));
           len = strnlen(buf2, sizeof(buf2));

           printf("[len = %zu]: ", len);
           fwrite(buf2, 1, len, stdout);
           putchar('\n');

           if (sizeof(buf1) < strlen("Hello world!"))
               errx("stpncpy: truncating character sequence");
           p = stpncpy(buf1, "Hello world!", sizeof(buf1));
           len = p - buf1;

           printf("[len = %zu]: ", len);
           fwrite(buf1, 1, len, stdout);
           putchar('\n');

           exit(EXIT_SUCCESS);
       }

[1mSEE ALSO[0m
       [1mwcpncpy[22m(3), [1mstring_copying[22m(7)

Linux man-pages 6.7                    2024-02-12                             [4mstpncpy[24m(3)
